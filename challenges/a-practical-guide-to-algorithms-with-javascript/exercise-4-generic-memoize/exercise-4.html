<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generic Memoize exercise</title>
</head>
<body>
<h1>Tasks</h1>
<ul>
    <li>Make your memo function generic and accept the times10 function as a callback rather than defining the n * 10
        logic inside the if/else or pulling it in from the global scope.
    </li>
    <li>Take advantage of the fact that parameters are saved in the closure as well, just like the cache from the
        previous example.
    </li>
</ul>

<pre>
    <code>
    var times10 = function (n) {
        return n * 10;
    };

    var memoize = function (cb) {};

    // returned function from memoizedAdd
    var memoizedTimes10 = memoize(times10);

    console.log('~~~~~~~~~~~~~~TASK 4~~~~~~~~~~~~~~');

    try {
        console.log('Task 4 calculated value:', memoizedTimes10(9));	// calculated
        console.log('Task 4 cached value:', memoizedTimes10(9));	// cached
    } catch(e) {
        console.error('Task 4:', e)
    }
    </code>
</pre>

<h2>Notes</h2>
<ul>
    <li>For space and time complexity the 3 solutions are consistent</li>
    <li>For our case where the callback is doing a constant time operation, the memoization has no time improvement. But
    this technique is important if you are doing very time consuming operations.</li>
    <li>In general you can trade space complexity for time complexity. How can we take a complex operation and turn it into constant or at least linear time, often it is using a hash table.</li>
</ul>

<script src="exercise-4.js"></script>
</body>
</html>